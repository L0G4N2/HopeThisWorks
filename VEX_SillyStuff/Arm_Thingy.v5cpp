{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\nmotor RoboticArm1_mJ1 = motor(PORT1, ratio18_1, false);\nmotor RoboticArm1_mJ2 = motor(PORT2, ratio18_1, true);\nmotor RoboticArm1_mJ3 = motor(PORT3, ratio18_1, false);\nmotor RoboticArm1_mJ4 = motor(PORT4, ratio18_1, false);\npot RoboticArm1_mJ1_pot = pot(Brain.ThreeWirePort.A);\npot RoboticArm1_mJ2_pot = pot(Brain.ThreeWirePort.B);\npot RoboticArm1_mJ3_pot = pot(Brain.ThreeWirePort.C);\npot RoboticArm1_mJ4_pot = pot(Brain.ThreeWirePort.D);\nRoboticArm RoboticArm1 = RoboticArm(RoboticArm1_mJ1, RoboticArm1_mJ1_pot, RoboticArm1_mJ2, RoboticArm1_mJ2_pot, RoboticArm1_mJ3, RoboticArm1_mJ3_pot, RoboticArm1_mJ4, RoboticArm1_mJ4_pot);\n\nbumper EStop = bumper(Brain.ThreeWirePort.E);\nelectromagnet Magnet5 = electromagnet(PORT5);\nmotor EntryMotor = motor(PORT7, ratio18_1, false);\n\nmotor TransportMotor = motor(PORT8, ratio18_1, false);\n\nmotor ExitMotor = motor(PORT9, ratio18_1, true);\n\nmotor DiverterMotor = motor(PORT10, ratio18_1, false);\n\noptical Optical6 = optical(PORT6);\nline Load = line(Brain.ThreeWirePort.F);\nline Pickup = line(Brain.ThreeWirePort.G);\nline Exit = line(Brain.ThreeWirePort.H);\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  int systemTime = Brain.Timer.systemHighResolution();\n  double batteryCurrent = Brain.Battery.current();\n  double batteryVoltage = Brain.Battery.voltage(voltageUnits::mV);\n\n  // Combine these values into a single integer\n  int seed = int(batteryVoltage + batteryCurrent * 100) + systemTime;\n\n  // Set the seed\n  srand(seed);\n}\n\n\n\nvoid vexcodeInit() {\n\n  //Initializing random seed.\n  initializeRandomSeed(); \n}\n\n\n// Helper to make playing sounds from the V5 in VEXcode easier and\n// keeps the code cleaner by making it clear what is happening.\nvoid playVexcodeSound(const char *soundName) {\n  printf(\"VEXPlaySound:%s\\n\", soundName);\n  wait(5, msec);\n}\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n// ----------------------------------------------------------------------------\n// \n//    Project:        Arm Workcell - With Sensors\n//    Description:    This example will help you get started with the V5\n//                    Workcell with sensors\n//    Configuration:  Workcell Arm\n//                    Electromagnet in port 5\n//                    Optical in Port 6\n//                    EntryMotor in Port 7\n//                    TransportMotor in Port 8\n//                    ExitMotor in Port 9\n//                    DiverterMotor in Port 10\n//                    Bumper in 3-Wire Port E\n//                    Load LineTracker in 3-Wire Port F\n//                    Pickup LineTracker in 3-Wire Port G\n//                    Exit LineTracker in 3-Wire Port H\n// \n// ----------------------------------------------------------------------------\n\n// Include the V5 Library\n#include \"vex.h\"\n  \n// Allows for easier use of the VEX Library\nusing namespace vex;\n\n// Function to run when the emergency stop button is pressed\nvoid onEStopPressed() {\n  RoboticArm1.emergencyStop();\n}\n\n// Task function to constantly display the arm position and sensor values on the brain screen\nint positionSensorDisplay() {\n  while (true) {\n    Brain.Screen.clearScreen();\n\n    // Display the X position on row 1\n    Brain.Screen.setCursor(1, 1);\n    Brain.Screen.print(\"Arm X: %0.3f\", RoboticArm1.getAxisPosition(xaxis));\n\n    // Display the Y position on row 2\n    Brain.Screen.newLine();\n    Brain.Screen.print(\"Arm Y: %0.3f\", RoboticArm1.getAxisPosition(yaxis));\n\n    // Display the Z position on row 3\n    Brain.Screen.newLine();\n    Brain.Screen.print(\"Arm Z: %0.3f\", RoboticArm1.getAxisPosition(zaxis));\n\n    // Display if a disk is detected on row 4\n    Brain.Screen.newLine();\n    Brain.Screen.print(\"Disk Detect: %s\", Optical6.isNearObject() ? \"TRUE\" : \"FALSE\");\n\n    // Display the color of the disk if an object is found on row 5\n    Brain.Screen.newLine();\n    Brain.Screen.print(\"R: %s\", Optical6.color() == red ? \"TRUE\" : \"FALSE\");\n    Brain.Screen.print(\" / B: %s\", Optical6.color() == blue ? \"TRUE\" : \"FALSE\");\n    Brain.Screen.print(\" / G: %s\", Optical6.color() == green ? \"TRUE\" : \"FALSE\");\n\n    // Display the percentage of light reflected back from the Load Sensor on row 6\n    Brain.Screen.newLine();\n    Brain.Screen.print(\"Load: %3d\", Load.reflectivity());\n\n    // Display the percentage of light reflected back from the Pickup Sensor on row 7\n    Brain.Screen.newLine();\n    Brain.Screen.print(\"Pickup: %3d\", Pickup.reflectivity());\n\n    // Display the percentage of light reflected back from the Exit Sensor on row 8\n    Brain.Screen.newLine();\n    Brain.Screen.print(\"Exit: %3d\", Exit.reflectivity());\n    wait(0.2, seconds);\n  }\n  return 0;\n}\n\nvoid divert() {\n  DiverterMotor.spin(forward);\n  wait(350, msec);\n  DiverterMotor.stop();\n}\n\nvoid resetDivert() {\n  DiverterMotor.spin(reverse);\n  wait(350, msec);\n  DiverterMotor.stop();\n}\n\nvoid returnToStart() {\n  RoboticArm1.moveToPositionJoint(RoboticArm1.getAxisPosition(xaxis), RoboticArm1.getAxisPosition(yaxis), RoboticArm1.getAxisPosition(zaxis) + 3);\n  wait(500, msec);\n  RoboticArm1.moveToPositionJoint((7.8 - RoboticArm1.getAxisPosition(xaxis)) + RoboticArm1.getAxisPosition(xaxis), (3.2 - RoboticArm1.getAxisPosition(yaxis)) + RoboticArm1.getAxisPosition(yaxis), (2.2 - RoboticArm1.getAxisPosition(zaxis)) + RoboticArm1.getAxisPosition(zaxis));\n}\nvoid moveToRedSpace() {\n  // Code here\n  RoboticArm1.moveToPositionJoint(RoboticArm1.getAxisPosition(xaxis), RoboticArm1.getAxisPosition(yaxis), RoboticArm1.getAxisPosition(zaxis) + 3);\n  RoboticArm1.moveToPositionJoint(8.5, 2, 3);\n  Magnet5.drop();\n}\n\nvoid moveToGreenSpace() {\n  // Code here\n}\n\nvoid moveToBlueSpace() {\n  // Code here\n}\n\nvoid moveToExit() {\n  // Code here\n  // Arm Start: ~(7.813, 3.167, 2.131)\n  RoboticArm1.moveToPositionJoint(RoboticArm1.getAxisPosition(xaxis), RoboticArm1.getAxisPosition(yaxis), RoboticArm1.getAxisPosition(zaxis) + 3);\n  RoboticArm1.moveToPositionJoint(RoboticArm1.getAxisPosition(xaxis) - 5, RoboticArm1.getAxisPosition(yaxis) + 7, 4);\n  wait(500, msec);\n  RoboticArm1.moveToPositionJoint(RoboticArm1.getAxisPosition(xaxis), RoboticArm1.getAxisPosition(yaxis), RoboticArm1.getAxisPosition(zaxis) - 1);\n  wait(500, msec);\n  Magnet5.pickup();\n}\n\nvoid moveToPickup() {\n  // Code here\n}\n\n// sort a red disc\nvoid onRedDetected() {\n  // Insert code here for sorting the red discs\n  if (!(Exit.reflectivity() <= 10 && Exit.reflectivity() >= 0)) {\n    wait(250, msec);\n  }\n  else {\n    EntryMotor.spin(forward);\n    wait(500, msec);\n    EntryMotor.stop();\n    TransportMotor.spin(forward);\n    while ((Load.reflectivity() <= 10 && Load.reflectivity() >= 0)) {\n      wait(250, msec);\n    }\n    divert();\n    ExitMotor.spin(forward);\n    while ((Exit.reflectivity() <= 10 && Exit.reflectivity() >= 0)) {\n      wait(250, msec);\n    }\n    TransportMotor.stop();\n    ExitMotor.stop();\n    resetDivert();\n    moveToExit();\n    moveToRedSpace();\n    returnToStart();\n  }\n}\n\n// sort a green disc\nvoid onGreenDetected() {\n  // Insert code here for sorting the green discs\n  if (!(Pickup.reflectivity() <= 10 && Pickup.reflectivity() >= 0)) {\n    wait(250, msec);\n  }\n  else {\n    EntryMotor.spin(forward);\n    wait(500, msec);\n    EntryMotor.stop();\n    TransportMotor.spin(forward);\n    waitUntil(Pickup.reflectivity() >= 10);\n    TransportMotor.stop();\n    // moveToPickup();\n    // moveToGreenSpace();\n    // returnToOrigin();\n  }\n}\n\n// sort a blue disc\nvoid onBlueDetected() {\n  // Insert code here for sorting the blue discs\n  EntryMotor.spin(forward);\n    wait(500, msec);\n    EntryMotor.stop();\n    TransportMotor.spin(forward);\n    waitUntil(Pickup.reflectivity() >= 10);\n    TransportMotor.stop();\n    // moveToPickup();\n    // moveToBlueSpace();\n    // returnToOrigin();\n}\n\nint main() {\n  // Initializing Robot Configuration. DO NOT REMOVE!\n  vexcodeInit();\n  // register emergency stop event handler\n  EStop.pressed(onEStopPressed);\n\n  // short wait to make sure the emergency stop event is fully registered\n  wait(15, msec);\n\n  // initial device setup\n  RoboticArm1.setMasteringValues(1800.0, 2150.0, 1900.0, 425.0);\n  RoboticArm1.setToolTipOffset(-0.7, 0.0, -1.0);\n  Magnet5.setPower(100);\n  Optical6.setLight(ledState::on);\n  Optical6.setLightPower(100, percent);\n  EntryMotor.setVelocity(70, percent);\n  TransportMotor.setVelocity(15, percent);\n  ExitMotor.setVelocity(50, percent);\n  DiverterMotor.setVelocity(30, percent);\n  Brain.Screen.setFont(mono30);\n\n  // start the position and sensor value display task\n  vex::task positionSensorDisplayTask(positionSensorDisplay);\n\n  // actual logic for sorting discs by color\n  while (true) {\n    waitUntil(Optical6.isNearObject());\n    if (Optical6.color() == red) {\n      onRedDetected();\n    }\n    else if (Optical6.color() == blue)\n    {\n      onBlueDetected();\n    }\n    else if (Optical6.color() == green)\n    {\n      onGreenDetected();\n    }\n    wait(5, msec);\n  }\n}","textLanguage":"cpp","robotConfig":[{"port":[1,2,3,4,1,2,3,4],"name":"RoboticArm1","customName":false,"deviceType":"RoboticArm","deviceClass":"RoboticArm","setting":{"configType":"standard"},"triportSourcePort":22},{"port":[5],"name":"EStop","customName":true,"deviceType":"Bumper","deviceClass":"bumper","setting":{},"triportSourcePort":22},{"port":[5],"name":"Magnet5","customName":false,"deviceType":"Magnet","deviceClass":"electromagnet","setting":{},"triportSourcePort":22},{"port":[7],"name":"EntryMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[8],"name":"TransportMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[9],"name":"ExitMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[10],"name":"DiverterMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[6],"name":"Optical6","customName":false,"deviceType":"Optical","deviceClass":"optical","setting":{},"triportSourcePort":22},{"port":[6],"name":"Load","customName":true,"deviceType":"LineTracker","deviceClass":"line","setting":{},"triportSourcePort":22},{"port":[7],"name":"Pickup","customName":true,"deviceType":"LineTracker","deviceClass":"line","setting":{},"triportSourcePort":22},{"port":[8],"name":"Exit","customName":true,"deviceType":"LineTracker","deviceClass":"line","setting":{},"triportSourcePort":22}],"slot":7,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.1.0","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}